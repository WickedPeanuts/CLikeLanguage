module clikelanguage

imports
  
  signatures/CLikeLanguage-sig
  completion/completion
  pp
  outline
  analysis

rules // Debugging
  
  debug-show-aterm:
    (node, _, _, path, project-path) -> (filename, result)
    with
      filename := <guarantee-extension(|"aterm")> path
    ; result   := node

  gera-xgcc:
    (node, position, ast, path, project-path) -> ("assembly.txt", <gera-prog> ast)
    
  // OK!
  gera-prog:
     Program(i, ld)  -> 
     $[.file	1	"assembly.c"
       .section	.mdebug.abi32
       .previous
       [<gera-program>(ld, ".text")]
       .text       
       .ident "GCC: (GNU) 4.9.0"]
       
  
  
  //Expression
  
  
  
  //AddExpr OK!
  gera-expression:
   (AddExpr(expr1, oprTerm, expr2), register, parentNode) ->
   $[[<gera-expression> (expr1, 2, parentNode)]
   [<gera-expression> (expr2, 3, parentNode)]
   [<gera-operatorTerm> oprTerm]]
  
  //MulExpr OK!
  gera-expression:
   (MulExpr(expr1, oprFact, expr2), register, parentNode) ->
   $[[<gera-expression> (expr1, 2, parentNode)]
   [<gera-expression> (expr2, 3, parentNode)]
   [<gera-operatorFact> oprFact]] 
  
  //LogicExpr OK! (caso derive de atribuição)
  gera-expression:
   (LogicExpr(expr1, oprCmp, expr2), register, "assignment") ->
   $[
   [<gera-expression> (expr1, 2)]
   [<gera-expression> (expr2, 3)]
   [<gera-operatorCmp> (oprCmp)]
   andi	$2,$2,0x00ff]
   
  //LogicExpr OK!
  gera-expression:
   (LogicExpr(expr1, oprCmp, expr2), register, parentNode) ->
   $[[<gera-expression> (expr1, 2, parentNode)]
   [<gera-expression> (expr2, 3, parentNode)]
   [<gera-operatorCmp> (oprCmp)]]
   
      
  //ParenthesisExpression OK!
  gera-expression:
   (ParenthesisExpression(expr), register, parentNode) ->
   $[[<gera-expression>(expr, 2, parentNode)]]
  
  //Primitive (Caso seja inteiro) OK!
  gera-expression:
   (IntegerPrim(args1), register, parentNode) ->
   $[li	$[register],[<gera-primitive> IntegerPrim(args1)]]
  
  //Primitive (Caso seja variável) OK!
  gera-expression:
   (Primitive, register, parentNode) ->
   $[lw	$[register],[<gera-primitive> Primitive]]
         
         
         
  //Primitives
  
  
  
  //True OK!
  gera-primitive:
   "true" ->
   $[1]
  
  //False OK!
  gera-primitive:
   "false" ->
   $[0]
  
  //Primitive Int OK!
  gera-primitive:
   IntegerPrim(arg1) ->
   $[[arg1]]
  
  //Primitive Char OK!
  gera-primitive:
   CharPrim(arg1) ->
   $[[arg1]]
  
  //Primitive Boolean OK!
  gera-primitive:
   BoolPrim(arg1) ->
   $[[arg1]]
  
  //Primitive ID OK!
  gera-primitive:
   IdentifierPrim(arg1) ->
   $[[arg1]]
   
      
  //Primitive.PrimitiveFunction OK!
  gera-primitive:
   PrimitiveFunction(varName, args) ->
   $[[<gera-argument> args]]
  
  
  
  //Operators
  
  
  
  //OperatorTerm.Add OK!
  gera-operatorTerm:
   Add() -> $[#nop
   addu	$2,$3,$2]
   
  //OperatorTerm.Add OK!
  gera-operatorTerm:
   Sub() -> $[#nop
   subu	$2,$3,$2]
   
  //OperatorFactor OK!
  gera-operatorFact:
   Mul() -> $[#nop
   mult	$3,$2
   mflo $3]
   
  //OperatorFactor OK!
  gera-operatorFact:
   Div() -> $[.set	noreorder
   bne	$2,$0,$1f
   div	$0,$3,$2
   break	7
   .set	reorder
   1:
   mfhi	$3
   mflo $2]
  
  //OperationComparator.Equal OK! (Em caso da variável receba a att)
  gera-operatorCmp:
   Equal() -> $[#nop
   xor	$2, $3, $2
   sltu	$2,$2,1]
   
  //OperationComparator.Diff OK!
  gera-operatorCmp:
   Diff() -> $[#nop
   xor	$2,$3,$2
   sltu	$2,$0,$2]
   
  //OperationComparator.GT OK!
  gera-operatorCmp:
   GT() -> $[#nop
   slt	$2,$2,$3]
   
  //OperationComparator.GTE OK!
  gera-operatorCmp:
   GTE() -> $[#nop
   slt	$2,$3,$2
   xori	$2,$2,0x1]
   
  //OperationComparator.LT OK!
  gera-operatorCmp:
   LT() -> $[#nop
   slt	$2,$3,$2]
   
  //OperationComparator.LTE OK!
  gera-operatorCmp:
   LTE() -> $[#nop
   slt	$2,$2,$3
   xori	$2,$2,0x1]
   
  //OperationComparator.And (Muito complicado!)
  gera-operatorCmp:
   And() -> $[&&]
  
  //OperationComparator (Muito complicado!)
  gera-operatorCmp:
   Or() -> $[||]
  
    
  
  //STATEMENT
  
  
  
  //Blank OK!
  gera-statement:
   ([], _,_) -> $[]

  //Break; (Caso seja chamado sem whiles, não gera código!) OK!
  gera-statement:
   ([Break()|tail], None(), functName) ->
   $[[<gera-statement>(tail, None(), functName)]]
   
  //Break; OK!
  gera-statement:
   ([Break()|tail], loopCount, _) ->
   $[j	$While_[loopCount]_END]
  
  //Codeblock OK!
  gera-statement:
   (Block(stmt), loopCount, functName) -> 
   $[[<gera-statement>(stmt, loopCount, functName)]]
   
  //If OK!
  gera-statement:
   ([If(expr, stmt, ifElseCond)|tail], loopCount, functName) ->
   $[#nop
   bne	$3,$2,$IF_[ifCount]_NOTEQUAL
   $IF_[ifCount]_BEGIN:			# Apenas para auxiliar no pensamento
   [<gera-statement>(stmt, loopCount, functName)]
   j	$IF_[ifCount]_END   
   $IF_[ifCount]_NOTEQUAL:
   [<gera-ifelse>(ifElseCond, loopCount, functName)]
   $IF_[ifCount]_END:
   [<gera-statement>(tail, loopCount, functName)]]
   with
     new-counter => ifCount
  //IFElse OK!
  gera-ifelse:
   (None(), _, _) -> $[]
  gera-ifelse:
   (Some(Single(stmt)), loopCount, functName) ->
   $[[<gera-statement>(stmt, loopCount, functName)]]
  
  //While OK!
  gera-statement:
   ([While(expr, stmt)|tail], loopCount, functName) ->
   $[
   j	$While_[newLoopCount]_END
   $While_[newLoopCount]_BEGIN:
   [<gera-statement>(stmt, newLoopCount, functName)]
   $While_[newLoopCount]_END:
   [<gera-expression> (expr, 2, "loop")]
   bne $2,$0,$While_[newLoopCount]_BEGIN
   [<gera-statement>(tail, loopCount, functName)]]
   with
     new-counter => newLoopCount
  
  //Return OK!
  gera-statement:
   ([Return(Some(expr))|tail], loopCount, functName) ->
   $[[<gera-expression> (expr, 2, "return")]
   j	$END_FUNCTION_[functName]]
  
  //Return (VOID) OK! 
  gera-statement:
   ([Return(None())|tail], loopCount, functName) ->
   $[j	$END_FUNCTION_[functName]]
  
  //Assignment OK!
  gera-statement:
   ([Assignment(varName, expr) | tail], loopCount, functName) ->
   $[[<gera-expression> (expr, 2, "assignment")]
   sw	$2,[varName]
   [<gera-statement> (tail, loopCount, functName)]]
  
  
  
  //Parameter (não sei se está no escopo do pj)
  
  
    
  //Parameter.Empty
  gera-parameter:
   [] -> $[]
  
  //Parameter.Parameter
  gera-parameter:
   [SimpleParameter(varType, ident)|tail] ->
   $[[<gera-parameter> tail]]
  
  //Parameter.Separator
  gera-parameter:
   [ParamSeparator(leftParam, rightParam)|tail] ->
   $[[<gera-parameter> [leftParam]]
   [<gera-parameter> [rightParam]]
   [<gera-parameter> tail]]
  
  
  
  //Argument (não sei se está no escopo do pj)
  
  
  
  gera-argument:
   [SingleArgument(expr)|tail] ->
   $[[<gera-argument> tail]]
   
  gera-argument:
   [ArguSeparator(leftExpr, rightExpr)|tail] ->
   $[[<gera-argument> [leftExpr]]
   [<gera-argument> [rightExpr]]
   [<gera-argument> tail]]
  
  
  //PROGRAM
   
  //Caso base OK!
  gera-program:
    ([],_) -> $[]
    
  //Function OK!
  //TODO GERAR PARAMETROS
  gera-program:
   ([Function(varType, ident, paramList, Block(stmtList))|tail], hasText) ->
    $[[ident]:
    [hasText]
    .align	2
	.globl	calcular
	.set	nomips16
	.ent	[ident]
	.type	[ident], @function
    [<gera-parameter> paramList]
    [<gera-statement> (stmtList, None(), funcName)]
    $END_FUNCTION_[funcName]:
    .end	[ident]
	.size	[ident], .-[ident]
	[<gera-program>(tail, "")]]
	with
		new-counter => funcName
  
  //Structure
  
  //Program.Structure OK
  gera-program:
   ([Structure(varList, ident)|tail], _) ->
    $[.comm	[ident], [memSize], 0
    [<gera-program>(tail, ".text")]]
    with
      memSize := <mul> (<length> varList, 4)
  
  //Variables
    
  //Variable.declarationInst
  gera-program:
   ([DeclarationInst(varType, ident, staticValue)|tail],_) ->
    $[.globl	[ident]
	.section	.sdata,"aw",@progbits
	.align	2
	.type	[ident], @object
	.size	[ident], 4
	[ident]:
	.word	 [<gera-primitive> staticValue]
    [<gera-program>(tail, ".text")]]
  
  //Variable.Declaration OK
  gera-program:
   ([Declaration(varType, ident)|tail], _) ->
    $[.comm	[ident],4,4
    [<gera-program>(tail, ".text")]]
  
  //Program.Variable.DeclarationArray OK
  gera-program:
   ([DeclarationArray(varType, ident, varSize)|tail], _) ->
    $[.comm	[ident],[memSize],0
    [<gera-program>(tail, ".text")]]
    with
      memSize := <mulS> (varSize, "4")