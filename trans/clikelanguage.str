module clikelanguage

imports
  
  signatures/CLikeLanguage-sig
  completion/completion
  pp
  outline
  analysis

rules // Debugging
  
  debug-show-aterm:
    (node, _, _, path, project-path) -> (filename, result)
    with
      filename := <guarantee-extension(|"aterm")> path
    ; result   := node

  gera-xgcc:
    (node, position, ast, path, project-path) -> ("assembly.txt", <gera-prog> ast)
    
  // OK!
  gera-prog:
     Program(i, ld)  -> 
     $[.file	1	"assembly.c"
       .section	.mdebug.abi32 
       .previous
       [<gera-program>(ld, ".text", globalVariables)]
       .text       
       .ident "GCC: (GNU) 4.9.0"]
     with
       new-hashtable => globalVariables
       
  
  
  //Expression
  
  
  
  //AddExpr OK!
  gera-expression:
   (AddExpr(expr1, oprTerm, expr2), register, parentNode) ->
   $[[<gera-expression> (expr1, 2, parentNode)]
   [<gera-expression> (expr2, 3, parentNode)]
   [<gera-operatorTerm> oprTerm]]
  
  //MulExpr OK!
  gera-expression:
   (MulExpr(expr1, oprFact, expr2), register, parentNode) ->
   $[[<gera-expression> (expr1, 2, parentNode)]
   [<gera-expression> (expr2, 3, parentNode)]
   [<gera-operatorFact> oprFact]] 
  
  //LogicExpr OK! (caso derive de atribuição)
  gera-expression:
   (LogicExpr(expr1, oprCmp, expr2), register, "assignment") ->
   $[
   [<gera-expression> (expr1, 2)]
   [<gera-expression> (expr2, 3)]
   [<gera-operatorCmp> (oprCmp)]
   andi	$2,$2,0x00ff]
   
  //LogicExpr OK!
  gera-expression:
   (LogicExpr(expr1, oprCmp, expr2), register, parentNode) ->
   $[[<gera-expression> (expr1, 2, parentNode)]
   [<gera-expression> (expr2, 3, parentNode)]
   [<gera-operatorCmp> (oprCmp)]]
   
      
  //ParenthesisExpression OK!
  gera-expression:
   (ParenthesisExpression(expr), register, parentNode) ->
   $[[<gera-expression>(expr, 2, parentNode)]]
  
  //Primitive (Caso seja inteiro) OK!
  gera-expression:
   (IntegerPrim(args1), register, parentNode) ->
   $[li	$[register],[<gera-primitive> IntegerPrim(args1)]]
  
  //Primitive (Caso seja variável) OK!
  gera-expression:
   (Primitive, register, parentNode) ->
   $[lw	$[register],[<gera-primitive> Primitive]]
         
         
         
  //Primitives
  
  
  
  //True OK!
  gera-primitive:
   "true" ->
   $[1]
  
  //False OK!
  gera-primitive:
   "false" ->
   $[0]
  
  //Primitive Int OK!
  gera-primitive:
   IntegerPrim(arg1) ->
   $[[arg1]]
  
  //Primitive Char OK!
  gera-primitive:
   CharPrim(arg1) ->
   $[[arg1]]
  
  //Primitive Boolean OK!
  gera-primitive:
   BoolPrim(arg1) ->
   $[[arg1]]
        
  //Primitive.PrimitiveFunction OK!
  gera-primitive:
   PrimitiveFunction(varName, args) ->
   $[[<gera-argument> args]]
  
  
  
  //Operators
  
  
  
  //OperatorTerm.Add OK!
  gera-operatorTerm:
   Add() -> $[#nop
   addu	$2,$3,$2]
   
  //OperatorTerm.Add OK!
  gera-operatorTerm:
   Sub() -> $[#nop
   subu	$2,$3,$2]
   
  //OperatorFactor OK!
  gera-operatorFact:
   Mul() -> $[#nop
   mult	$3,$2
   mflo $3]
   
  //OperatorFactor OK!
  gera-operatorFact:
   Div() -> $[.set	noreorder
   bne	$2,$0,$1f
   div	$0,$3,$2
   break	7
   .set	reorder
   1:
   mfhi	$3
   mflo $2]
  
  //OperationComparator.Equal OK! (Em caso da variável receba a att)
  gera-operatorCmp:
   Equal() -> $[#nop
   xor	$2, $3, $2
   sltu	$2,$2,1]
   
  //OperationComparator.Diff OK!
  gera-operatorCmp:
   Diff() -> $[#nop
   xor	$2,$3,$2
   sltu	$2,$0,$2]
   
  //OperationComparator.GT OK!
  gera-operatorCmp:
   GT() -> $[#nop
   slt	$2,$2,$3]
   
  //OperationComparator.GTE OK!
  gera-operatorCmp:
   GTE() -> $[#nop
   slt	$2,$3,$2
   xori	$2,$2,0x1]
   
  //OperationComparator.LT OK!
  gera-operatorCmp:
   LT() -> $[#nop
   slt	$2,$3,$2]
   
  //OperationComparator.LTE OK!
  gera-operatorCmp:
   LTE() -> $[#nop
   slt	$2,$2,$3
   xori	$2,$2,0x1]
   
  //OperationComparator.And (Muito complicado!)
  gera-operatorCmp:
   And() -> $[&&]
  
  //OperationComparator (Muito complicado!)
  gera-operatorCmp:
   Or() -> $[||]
  
    
  
  //STATEMENT
  
  
  
  //Blank OK!
  gera-statement:
   ([], _,_, _) -> $[]

  //Break; (Caso seja chamado sem whiles, não gera código!) OK!
  gera-statement:
   ([Break()|tail], None(), functName, globalVariables) ->
   $[[<gera-statement>(tail, None(), functName, globalVariables)]]
   
  //Break; OK!
  gera-statement:
   ([Break()|tail], loopCount, _, globalVariables) ->
   $[j	$While_[loopCount]_END]
  
  //Codeblock OK!
  gera-statement:
   (Block(stmt), loopCount, functName, globalVariables) -> 
   $[[<gera-statement>(stmt, loopCount, functName, globalVariables)]]
   
  //If OK!
  gera-statement:
   ([If(expr, stmt, ifElseCond)|tail], loopCount, functName, globalVariables) ->
   $[#nop
   bne	$3,$2,$IF_[ifCount]_NOTEQUAL
   $IF_[ifCount]_BEGIN:			# Apenas para auxiliar no pensamento
   [<gera-statement>(stmt, loopCount, functName, globalVariables)]
   j	$IF_[ifCount]_END   
   $IF_[ifCount]_NOTEQUAL:
   [<gera-ifelse>(ifElseCond, loopCount, functName, globalVariables)]
   $IF_[ifCount]_END:
   [<gera-statement>(tail, loopCount, functName, globalVariables)]]
   with
     new-counter => ifCount
  //IFElse OK!
  gera-ifelse:
   (None(), _, _) -> $[]
  gera-ifelse:
   (Some(Single(stmt)), loopCount, functName, globalVariables) ->
   $[[<gera-statement>(stmt, loopCount, functName, globalVariables)]]
  
  //While OK!
  gera-statement:
   ([While(expr, stmt)|tail], loopCount, functName, globalVariables) ->
   $[
   j	$While_[newLoopCount]_END
   $While_[newLoopCount]_BEGIN:
   [<gera-statement>(stmt, newLoopCount, functName, globalVariables)]
   $While_[newLoopCount]_END:
   [<gera-expression> (expr, 2, "loop")]
   bne $2,$0,$While_[newLoopCount]_BEGIN
   [<gera-statement>(tail, loopCount, functName, globalVariables)]]
   with
     new-counter => newLoopCount
  
  //Return OK!
  gera-statement:
   ([Return(Some(expr))|tail], loopCount, functName, globalVariables) ->
   $[[<gera-expression> (expr, 2, "return")]
   j	$END_FUNCTION_[functName]]
  
  //Return (VOID) OK! 
  gera-statement:
   ([Return(None())|tail], loopCount, functName, globalVariables) ->
   $[j	$END_FUNCTION_[functName]]
  
  //Assignment Work in progress...
  gera-statement:
   ([Assignment(leftExpr, rightExpr) | tail], loopCount, functName, globalVariables) ->
   $[[<gera-rightexpr> (rightExpr, startingValRegister, "assignment", globalVariables)]
   [<gera-leftexpr> (leftExpr, startingVarRegister, "assignment", globalVariables)]
   la $2,[<pegar-nome> leftExpr]
   add $2,$[startingVarRegister],$2
   sw $2,$[startingValRegister]
   [<gera-statement> (tail, loopCount, functName, globalVariables)]]
   with
     startingValRegister := 4;
     startingVarRegister := 16
  
  gera-leftexpr:
   (ArrayCall(leftExpr, rightExpr), register, opType, globalVariables) ->
   $[[<gera-rightexpr> (rightExpr, register, opType, globalVariables)]
   [<gera-leftexpr> (leftExpr, register, opType, globalVariables)]]
   with
     varSpace := "3"
  
  gera-leftexpr:
   (FieldCall(leftExpr, ident), register, opType, globalVariables) ->
   $[[<gera-leftexpr> (leftExpr, register, opType, globalVariables)]]
   with
     varSpace := "0"
     
  gera-leftexpr:
   (VariableCall(ident), register, opType, globalVariables) ->
   $[sw $2, [ident]+[varSpace]]
   with
     varSpace := "0"
   
  gera-rightexpr:
   (LeftExpressionTerm(leftExpr), register, opType, globalVariables) ->
   $[[<gera-leftexpr> (leftExpr, newRegister, opType, globalVariables)]
   move $[register],$[newRegister]
   ]
   with
     newRegister := <add> (register, 1)
  
  gera-rightexpr:
   (ExpressionTerm(expr), register, opType, globalVariables) ->
   $[[<gera-expression> (expr, 2, opType)]
   move $[register],$2
   ]
   
   
  
  //Parameter (não sei se está no escopo do pj)
  
  
    
  //Parameter.Empty
  gera-parameter:
   [] -> $[]
  
  //Parameter.Parameter
  gera-parameter:
   [SimpleParameter(varType, ident)|tail] ->
   $[[<gera-parameter> tail]]
  
  //Parameter.Separator
  gera-parameter:
   [ParamSeparator(leftParam, rightParam)|tail] ->
   $[[<gera-parameter> [leftParam]]
   [<gera-parameter> [rightParam]]
   [<gera-parameter> tail]]
  
  
  
  //Argument (não sei se está no escopo do pj)
  
  
  
  gera-argument:
   [SingleArgument(expr)|tail] ->
   $[[<gera-argument> tail]]
   
  gera-argument:
   [ArguSeparator(leftExpr, rightExpr)|tail] ->
   $[[<gera-argument> [leftExpr]]
   [<gera-argument> [rightExpr]]
   [<gera-argument> tail]]
  
  
  
  //PROGRAM
  
  
   
  //Caso base OK!
  gera-program:
    ([],_,_) -> $[]
    
  //Function OK!
  //TODO GERAR PARAMETROS
  gera-program:
   ([Function(varType, ident, paramList, Block(stmtList))|tail], hasText, globalVariables) ->
    $[[ident]:
    [hasText]
    .align	2
	.globl	calcular
	.set	nomips16
	.ent	[ident]
	.type	[ident], @function
    [<gera-parameter> paramList]
    [<gera-statement> (stmtList, None(), funcName, globalVariables)]
    $END_FUNCTION_[funcName]:
    .end	[ident]
	.size	[ident], .-[ident]
	[<gera-program>(tail, "", globalVariables)]]
	with
		new-counter => funcName
  
  
  
  //Structure & Variables
  
  
  
  //Structure 
  
  //Program.Structure OK
  gera-program:
   ([Structure(varList, ident)|tail], _, globalVariables) ->
    $[.comm	[ident], [memSize], 4
    [<gera-program>(tail, ".text", globalVariables)]]
    with
      memSize := <calcular-tamanho> (varList, "0");
      <hashtable-put(|ident, varList)> globalVariables
      
  //Program.StructureArray
  gera-program:
  ([StructureArray(varList, ident, arraySize)|tail], _, globalVariables) ->
   $[.comm [ident], [memSize], 4
   [<gera-program>(tail, ".text", globalVariables)]]
   with
     tamanhoAtributo := <calcular-tamanho> (varList, "0");
     memSize := <mulS> (tamanhoAtributo, arraySize);
     <hashtable-put(|ident, varList)> globalVariables
  
  //Variables
    
  //Variable.declarationInst
  gera-program:
   ([DeclarationInst(varType, ident, staticValue)|tail],_, globalVariables) ->
    $[.globl	[ident]
	.section	.sdata,"aw",@progbits
	.align	2
	.type	[ident], @object
	.size	[ident], [varSize]
	[ident]:
	.word	 [<gera-primitive> staticValue]
    [<gera-program>(tail, ".text", globalVariables)]]
    with
      varSize := <calcular-tamanho-primitivo> varType
  
  //Variable.Declaration OK
  gera-program:
   ([Declaration(varType, ident)|tail], _, globalVariables) ->
    $[.comm	[ident],[varSize],4
    [<gera-program>(tail, ".text", globalVariables)]]
    with
      varSize := <calcular-tamanho-primitivo> varType
  
  //Program.Variable.DeclarationArray OK
  gera-program:
   ([DeclarationArray(varType, ident, varSize)|tail], _, globalVariables) ->
    $[.comm	[ident],[memSize],4
    [<gera-program>(tail, ".text", globalVariables)]]
    with
      memSize := <calcular-tamanho> [DeclarationArray(varType, ident, varSize)]
      
  
  
  //Métodos Auxiliares
  
  
  
  pegar-tipo:
   VariableCall(varName) -> $[]
  
  pegar-tipo:
   ArrayCall(leftExpr, rightExpr) -> $[]
  
  pegar-tipo:
   FieldCall(leftExpr, rightExpr) -> $[]
  
  //Descobrir nome da variável
  pegar-nome:
   VariableCall(varName) -> $[varName]
  
  pegar-nome:
   ArrayCall(leftExpr, rightExpr) -> $[[<pegar-nome> leftExpr]]
  
  pegar-nome:
   FieldCall(leftExpr, varName) -> $[[<pegar-nome> leftExpr]]
  
  //Calcular Tamanho De uma Variável  
  calcular-tamanho:
   ([],size) -> $[[size]]
     
  calcular-tamanho:
   ([head|tail], size) -> $[[<calcular-tamanho> (tail, memSize)]]
   with
     varSize := <calcular-tamanho-primitivo> head;
     memSize := <addS> (varSize, size)
       
  calcular-tamanho-primitivo:
   DeclarationArray(type, _, size) -> $[[memSize]]
   with
     varSize := <calcular-tamanho-primitivo> type;
     memSize := <mulS> (size, varSize)
    
  calcular-tamanho-primitivo:
   Integer() -> $[4] 
   
  calcular-tamanho-primitivo:
   Char() -> $[1]
      
  calcular-tamanho-primitivo:
   Boolean() -> $[4]