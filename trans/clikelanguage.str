module clikelanguage

imports
  
  signatures/CLikeLanguage-sig
  completion/completion
  pp
  outline
  analysis

rules // Debugging
  
  debug-show-aterm:
    (node, _, _, path, project-path) -> (filename, result)
    with
      filename := <guarantee-extension(|"aterm")> path
    ; result   := node

  gera-xgcc:
    (node, position, ast, path, project-path) -> ("assembly.txt", <gera-prog> ast)
    
  gera-prog:
     Program(i, ld)  -> 
     $[.file	1	"assembly.c"
       .section	.mdebug.abi32
       .previous
       
       [<gera-program>ld]
       
       .ident "GCC: (GNU) 4.9.0"]
       
  
  
  //Expression
  
  
  
  //AddExpr OK!
  gera-expression:
   (AddExpr(expr1, oprTerm, expr2), register) ->
   $[[<gera-expression> (expr1, 2)]
   [<gera-expression> (expr2, 3)]
   [<gera-operatorTerm> oprTerm]]
  
  //MulExpr OK!
  gera-expression:
   (MulExpr(expr1, oprFact, expr2), register) ->
   $[[<gera-expression> (expr1, 2)]
   [<gera-expression> (expr2, 3)]
   [<gera-operatorFact> oprFact]] 
  
  //LogicExpr
  gera-expression:
   (LogicExpr(expr1, oprCmp, expr2), register) ->
   $[[<gera-expression> (expr1, 2)]
   [<gera-expression> (expr2, 3)]
   [<gera-operatorCmp> oprCmp]]
   
  //ParenthesisExpression OK!
  gera-expression:
   (ParenthesisExpression(expr), register) ->
   $[[<gera-expression>(expr, 0)]]
  
  //Primitive OK!
  gera-expression:
   (Primitive, register) ->
   $[lw	$[register], [<gera-primitive> Primitive]]
         
         
         
  //Primitives
  
  
  
  //True
  gera-primitive:
   "true" ->
   $[1]
  
  //False
  gera-primitive:
   "false" ->
   $[0]
  
  //Primitive
  gera-primitive:
   Primitive ->
   $[[Primitive]]
      
  //Primitive.PrimitiveFunction
  gera-primitive:
   PrimitiveFunction(varName, args) ->
   $[[<gera-argument> args]]
  
  
  
  //Operators
  
  
  
  //OperatorTerm.Add OK!
  gera-operatorTerm:
   Add() -> $[#nop
   addu	$2,$3,$2]
   
  //OperatorTerm.Add OK!
  gera-operatorTerm:
   Sub() -> $[#nop
   subu	$2,$3,$2]
   
  //OperatorFactor OK!
  gera-operatorFact:
   Mul() -> $[#nop
   mult	$3,$2
   mflo $3]
   
  //OperatorFactor OK!
  gera-operatorFact:
   Div() -> $[.set	noreorder
   bne	$2,$0,$1f
   div	$0,$3,$2
   break	7
   .set	reorder
   1:
   mfhi	$3
   mflo $2]
  
  //OperationComparator.Equal
  gera-operatorCmp:
   Equal() -> $[#nop
   xor	$2, $3, $2
   sltu	$2,$2,1
   andi	$2,$2,0x00ff]
   
  //OperationComparator.Diff
  gera-operatorCmp:
   Diff() -> $[#nop
   xor	$2, $3, $2
   sltu	$2,$0,$2
   andi	$2,$2,0x00ff]
   
  //OperationComparator.GT
  gera-operatorCmp:
   GT() -> $[#nop
   slt	$2,$2,$3
   andi	$2,$2,0x00ff]
   
  //OperationComparator.GTE
  gera-operatorCmp:
   GTE() -> $[#nop
   slt	$2,$3,$2
   xori	$2,$2,0x1
   andi	$2,$2,0x00ff]
   
  //OperationComparator.LT
  gera-operatorCmp:
   LT() -> $[#nop
   slt	$2,$0,$2
   andi	$2,$2,0x00ff]
   
  //OperationComparator.LTE
  gera-operatorCmp:
   LTE() -> $[#nop
   slt	$2,$2,$3
   xori	$2,$2,0x1
   andi	$2,$2,0x00ff]
   
  //OperationComparator.And (Muito complicado!)
  gera-operatorCmp:
   And() -> $[&&]
  
  //OperationComparator (Muito complicado!)
  gera-operatorCmp:
   Or() -> $[||]
  
    
  
  //STATEMENT
  
  
  
  //Blank
  gera-statement:
   ([], loopCount) -> $[]
   
  //Break;
  gera-statement:
   ([Break()|tail], loopCount) ->
   $[Break_[loopCount];]
  
  //Codeblock OK!
  gera-statement:
   (Block(stmt), loopCount) -> 
   $[[<gera-statement>(stmt, loopCount)]]
   
  //If OK!
  gera-statement:
   ([If(expr, stmt, ifElseCond)|tail], loopCount) ->
   $[#nop
   bne	$3,$2,$IF_[ifCount]_NOTEQUAL
   $IF_[ifCount]_BEGIN:			# Apenas para auxiliar no pensamento
   [<gera-statement>(stmt, loopCount)]
   j	$IF_[ifCount]_END   
   $IF_[ifCount]_NOTEQUAL:
   [<gera-ifelse>(ifElseCond, loopCount)]
   $IF_[ifCount]_END:
   [<gera-statement>(tail, loopCount)]]
   with
     new-counter => ifCount
  //IFElse
  gera-ifelse:
   (None(), loopCount) -> $[]
  gera-ifelse:
   (Some(Single(stmt)), loopCount) ->
   $[[<gera-statement>(stmt, loopCount)]]
  
  //While
  gera-statement:
   ([While(expr, stmt)|tail], loopCount) ->
   $[$While_[newLoopCount]_BEGIN:
   [<gera-statement>(stmt, newLoopCount)]
   $While_[newLoopCount]_END:
   [<gera-statement>(tail, loopCount)]]
   with
     new-counter => newLoopCount
  
  //Return
  gera-statement:
   ([Return(expr)|tail], loopCount) ->
   $[Return;]
  
  //Assignment OK!
  gera-statement:
   ([Assignment(varName, expr) | tail], loopCount) ->
   $[[<gera-expression> (expr, 0)]
   sw	$2,[varName]
   [<gera-statement> (tail, loopCount)]]
  
  
  //Parameter (não sei se está no escopo do pj)
  
  
    
  //Parameter.Empty
  gera-parameter:
   [] -> $[]
  
  //Parameter.Parameter
  gera-parameter:
   [SimpleParameter(varType, ident)|tail] ->
   $[[<gera-parameter> tail]]
  
  //Parameter.Separator
  gera-parameter:
   [ParamSeparator(leftParam, rightParam)|tail] ->
   $[[<gera-parameter> [leftParam]]
   [<gera-parameter> [rightParam]]
   [<gera-parameter> tail]]
  
  
  
  //Argument (não sei se está no escopo do pj)
  
  
  
  gera-argument:
   [SingleArgument(expr)|tail] ->
   $[[<gera-argument> tail]]
   
  gera-argument:
   [ArguSeparator(leftExpr, rightExpr)|tail] ->
   $[[<gera-argument> [leftExpr]]
   [<gera-argument> [rightExpr]]
   [<gera-argument> tail]]
  
  
  //PROGRAM
  
  //Caso base OK!
  gera-program:
    [] -> $[]
    
  //Function
  //TODO GERAR PARAMETROS
  gera-program:
   [Function(varType, ident, paramList, Block(stmtList))|tail] ->
    $[[ident]:
    [<gera-parameter> paramList]
    [<gera-statement> (stmtList, 0)]
    .end	[ident]
	.size	[ident], .-[ident]
	.ident	"GCC: (GNU) 4.9.0"
	[<gera-program>tail]]
  
  //Structure
  
  //Program.Structure OK
  gera-program:
   [Structure(varList, ident)|tail] ->
    $[.comm	[ident], [memSize], 0
    [<gera-program>tail]]
    with
      memSize := <mul> (<length> varList, 4)
  
  //Variables
    
  //Program.Variable.DeclarationInst TODO EXPR
  gera-program:
   [DeclarationInst(varType, ident, expr)|tail] ->
    $[.comm	[ident],4,4
    [<gera-program>tail]]
  
  //Variable.Declaration OK
  gera-program:
   [Declaration(varType, ident)|tail] ->
    $[.comm	[ident],4,4
    [<gera-program>tail]]
  
  //Program.Variable.DeclarationArray OK
  gera-program:
   [DeclarationArray(varType, ident, varSize)|tail] ->
    $[.comm	[ident],[memSize],0
    [<gera-program>tail]]
    with
      memSize := <mulS> (varSize, "4")