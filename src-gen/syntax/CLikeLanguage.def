definition
module Common
exports
  lexical syntax
    [a-zA-Z] [a-zA-Z0-9]*    -> ID            
    BOOLEAN                  -> ID            {reject}
    "-"? [0-9]+              -> INT           
    "'" [a-zA-Z] "'"         -> CHAR          
    "true" | "false"         -> BOOLEAN       
    "\"" StringChar* "\""    -> STRING        
    ~[\"\n]                  -> StringChar    
    "\\\""                   -> StringChar    
    BackSlashChar            -> StringChar    
    "\\"                     -> BackSlashChar 
    [\ \t\n\r]               -> LAYOUT        
    [\*]                     -> CommentChar   
    "/*" InsideComment* "*/" -> LAYOUT        
    ~[\*]                    -> InsideComment 
    CommentChar              -> InsideComment 
    "//" ~[\n\r]* NewLineEOF -> LAYOUT        
    [\n\r]                   -> NewLineEOF    
    EOF                      -> NewLineEOF    
                             -> EOF           

  lexical restrictions
    CommentChar -/- [\/]
    INT -/- [0-9]
    ID -/- [a-zA-Z0-9\_]
    EOF -/- ~[]
    BackSlashChar -/- [\"]

  context-free restrictions
    LAYOUT? -/- [\ \t\n\r]
    LAYOUT? -/- [\/] . [\/]
    LAYOUT? -/- [\/] . [\*]

module CLikeLanguage
imports Common

exports
  context-free start-symbols
    Start

  sorts Variable Expression Code Parameter

  context-free syntax
    "program" ID "{" Program* "}"            -> Start                {cons("Program")}
    Structure                                -> Program              {cons("Structure")}
    Function                                 -> Program              {cons("Function")}
    "struct" ID "{" Variable* "}" ";"        -> Structure            {cons("Declaration")}
    Type ID "(" Parameter* ")" CodeBlock     -> Function             {cons("Declaration")}
    "{" Statement* "}"                       -> CodeBlock            {cons("Block")}
    If                                       -> Statement            {cons("If")}
    "while" "(" Expression ")" CodeBlock     -> Statement            {cons("While")}
    Variable                                 -> Statement            {cons("VariableDeclaration")}
    ID "=" Expression ";"                    -> Statement            {cons("Attribution")}
    IfHeader CodeBlock IfElse?               -> If                   {cons("Block")}
    IfHeader Statement IfElse?               -> If                   {cons("Single")}
    "else" CodeBlock                         -> IfElse               {cons("Block")}
    "else" Statement                         -> IfElse               {cons("Single")}
    "if" "(" Expression ")"                  -> IfHeader             {cons("Declaration")}
    Type ID ";"                              -> Variable             {cons("Declaration")}
    Type ID "[];"                            -> Variable             {cons("DeclarationArray")}
    Type ID "=" Expression ";"               -> Variable             {cons("DeclarationInst")}
    Type ID                                  -> Parameter            {cons("Parameter")}
    Parameter "," Parameter                  -> Parameter            {cons("Separator"), left}
    Expression                               -> Argument             {cons("Parameter")}
    Expression "," Expression                -> Argument             {cons("Separator"), left}
    Expression OperatorComparator Expression -> ExpressionComparator {cons("Comparator"), left}
    ExpressionComparator                     -> Expression           {cons("Comparator"), left}
    Term                                     -> Expression           {cons("Term"), left}
    Expression OperatorTerm Term             -> Expression           {cons("Term"), left}
    Factor                                   -> Term                 {cons("Factor"), left}
    Term OperatorFactor Factor               -> Term                 {cons("Factor"), left}
    Primitive                                -> Factor               {cons("Primitive"), left}
    "(" Expression ")"                       -> Factor               {cons("Expression"), left}
    INT                                      -> Primitive            {cons("Num")}
    CHAR                                     -> Primitive            {cons("Char")}
    BOOLEAN                                  -> Primitive            {cons("Boolean")}
    ID                                       -> Primitive            {cons("Variable")}
    ID "(" Argument* ")"                     -> Primitive            {cons("Function")}
    "+"                                      -> OperatorTerm         {cons("Add")}
    "-"                                      -> OperatorTerm         {cons("Sub")}
    "*"                                      -> OperatorFactor       {cons("Mul")}
    "/"                                      -> OperatorFactor       {cons("Div")}
    "=="                                     -> OperatorComparator   {cons("Equal")}
    "!="                                     -> OperatorComparator   {cons("Diff")}
    ">"                                      -> OperatorComparator   {cons("GT")}
    ">="                                     -> OperatorComparator   {cons("GTE")}
    "<"                                      -> OperatorComparator   {cons("LT")}
    "<="                                     -> OperatorComparator   {cons("LTE")}
    "&&"                                     -> OperatorComparator   {cons("And")}
    "||"                                     -> OperatorComparator   {cons("Or")}
    "void"                                   -> Type                 {cons("Void")}
    "int"                                    -> Type                 {cons("Integer")}
    "char"                                   -> Type                 {cons("Char")}
    "bool"                                   -> Type                 {cons("Boolean")}

  lexical syntax
    

  context-free syntax
    "$Start"                -> Start                {cons("Start-Plhdr"), placeholder}
    "$Program"              -> Program              {cons("Program-Plhdr"), placeholder}
    "$Structure"            -> Structure            {cons("Structure-Plhdr"), placeholder}
    "$Function"             -> Function             {cons("Function-Plhdr"), placeholder}
    "$If"                   -> If                   {cons("If-Plhdr"), placeholder}
    "$CodeBlock"            -> CodeBlock            {cons("CodeBlock-Plhdr"), placeholder}
    "$IfElse"               -> IfElse               {cons("IfElse-Plhdr"), placeholder}
    "$Statement"            -> Statement            {cons("Statement-Plhdr"), placeholder}
    "$IfHeader"             -> IfHeader             {cons("IfHeader-Plhdr"), placeholder}
    "$Variable"             -> Variable             {cons("Variable-Plhdr"), placeholder}
    "$Parameter"            -> Parameter            {cons("Parameter-Plhdr"), placeholder}
    "$ExpressionComparator" -> ExpressionComparator {cons("ExpressionComparator-Plhdr"), placeholder}
    "$Term"                 -> Term                 {cons("Term-Plhdr"), placeholder}
    "$Factor"               -> Factor               {cons("Factor-Plhdr"), placeholder}
    "$Expression"           -> Expression           {cons("Expression-Plhdr"), placeholder}
    "$INT"                  -> INT                  {cons("INT-Plhdr"), placeholder}
    "$CHAR"                 -> CHAR                 {cons("CHAR-Plhdr"), placeholder}
    "$BOOLEAN"              -> BOOLEAN              {cons("BOOLEAN-Plhdr"), placeholder}
    "$Primitive"            -> Primitive            {cons("Primitive-Plhdr"), placeholder}
    "$ID"                   -> ID                   {cons("ID-Plhdr"), placeholder}
    "$Argument"             -> Argument             {cons("Argument-Plhdr"), placeholder}
    "$OperatorTerm"         -> OperatorTerm         {cons("OperatorTerm-Plhdr"), placeholder}
    "$OperatorFactor"       -> OperatorFactor       {cons("OperatorFactor-Plhdr"), placeholder}
    "$OperatorComparator"   -> OperatorComparator   {cons("OperatorComparator-Plhdr"), placeholder}
    "$Type"                 -> Type                 {cons("Type-Plhdr"), placeholder}