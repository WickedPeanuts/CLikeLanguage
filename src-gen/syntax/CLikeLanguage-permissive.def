definition

module Common
exports
  sorts WATER WATERTOKEN WATERTOKENSTART WATERTOKENSEPARATOR WATERTOKENSTAR

  lexical syntax
    [A-Za-z0-9\_]                  -> WATERTOKENSTART     {recover, avoid}
    WATERTOKENSTART [A-Za-z0-9\_]* -> WATERTOKEN          
    ~[A-Za-z0-9\_\ \t\12\r\n\*]    -> WATERTOKENSEPARATOR {recover, avoid}
    "*"                            -> WATERTOKENSTAR      {recover, avoid}
    WATERTOKEN                     -> WATER               
    WATERTOKENSEPARATOR            -> WATER               
    WATERTOKENSTAR                 -> WATER               
                                   -> WATEREOF            

  lexical restrictions
    WATERTOKEN -/- [A-Za-z0-9\_]
    WATERTOKENSTAR -/- [\/]

  context-free syntax
    WATER -> LAYOUT {cons("WATER")}

  (

  sorts WATEREOF

  lexical restrictions
    WATEREOF -/- ~[]

  lexical syntax
    %% Lexical insertion recovery rules                     
    "'"                                  -> INSERTOPENQUOTE {recover}
    INSERTOPENQUOTE [a-zA-Z] "\n"        -> CHAR            {cons("INSERTEND")}
    INSERTOPENQUOTE [a-zA-Z] WATEREOF    -> CHAR            {cons("INSERTEND")}
    "\""                                 -> INSERTOPENQUOTE {recover}
    INSERTOPENQUOTE StringChar* "\n"     -> STRING          {cons("INSERTEND")}
    INSERTOPENQUOTE StringChar* WATEREOF -> STRING          {cons("INSERTEND")}
    "/*"                                 -> INSERTSTART     {recover}
    INSERTSTART InsideComment* WATEREOF  -> LAYOUT          {cons("INSERTEND")}
                                         -> "program"       {recover, cons("INSERTION")}
                                         -> "{"             {recover, cons("INSERTION")}
                                         -> "struct"        {recover, cons("INSERTION")}
                                         -> "}"             {recover, cons("INSERTION")}
                                         -> ";"             {recover, cons("INSERTION")}
                                         -> "if"            {recover, cons("INSERTION")}
                                         -> "print"         {recover, cons("INSERTION")}
                                         -> ")"             {recover, cons("INSERTION")}
                                         -> "scan"          {recover, cons("INSERTION")}
                                         -> "$Start"        {recover, cons("INSERTION")}

  syntax
    %% Kernel syntax insertion recovery rules   

  )

  (

  lexical syntax
    [a-zA-Z] [a-zA-Z0-9]*    -> ID            
    BOOLEAN                  -> ID            {reject}
    "-"? [0-9]+              -> INT           
    "'" [a-zA-Z] "'"         -> CHAR          
    "true" | "false"         -> BOOLEAN       
    "\"" StringChar* "\""    -> STRING        
    "%c" | "%i" | "%s"       -> INPUT         
    ~[\"\n]                  -> StringChar    
    "\\\""                   -> StringChar    
    BackSlashChar            -> StringChar    
    "\\"                     -> BackSlashChar 
    [\ \t\n\r]               -> LAYOUT        
    [\*]                     -> CommentChar   
    "/*" InsideComment* "*/" -> LAYOUT        
    ~[\*]                    -> InsideComment 
    CommentChar              -> InsideComment 
    "//" ~[\n\r]* NewLineEOF -> LAYOUT        
    [\n\r]                   -> NewLineEOF    
    EOF                      -> NewLineEOF    
                             -> EOF           

  lexical restrictions
    CommentChar -/- [\/]
    INT -/- [0-9]
    ID -/- [a-zA-Z0-9\_]
    EOF -/- ~[]
    BackSlashChar -/- [\"]

  context-free restrictions
    LAYOUT? -/- [\ \t\n\r]
    LAYOUT? -/- [\/] . [\/]
    LAYOUT? -/- [\/] . [\*]

  )

module CLikeLanguage
imports Common

exports
  context-free start-symbols
    Start

  sorts Variable Expression Code Parameter

  context-free syntax
    "program" ID "{" Program* "}"            -> Start              {cons("Program")}
    GlobalVariable                           -> Program            {cons("GlobalVariable")}
    Structure                                -> Program            {cons("Structure")}
    Function                                 -> Program            {cons("Function")}
    Type ID ";"                              -> GlobalVariable     {cons("GlobalDeclaration")}
    Type ID "[];"                            -> GlobalVariable     {cons("GlobalDeclarationArray")}
    Type ID "=" Expression ";"               -> GlobalVariable     {cons("GlobalDeclarationInst")}
    "struct" ID "{" Variable* "}" ";"        -> Structure          {cons("Declaration")}
    Type ID "(" Parameter* ")" CodeBlock     -> Function           {cons("Declaration")}
    "{" Statement* "}"                       -> CodeBlock          {cons("Block")}
    If                                       -> Statement          {cons("If")}
    "while" "(" Expression ")" CodeBlock     -> Statement          {cons("While")}
    Variable                                 -> Statement          {cons("VariableDeclaration")}
    ID "=" Expression ";"                    -> Statement          {cons("Attribution")}
    "break;"                                 -> Statement          {cons("Break")}
    "return" Expression ";"                  -> Statement          {cons("Return")}
    IfHeader CodeBlock IfElse?               -> If                 {cons("Block")}
    IfHeader Statement IfElse?               -> If                 {cons("Single")}
    "else" CodeBlock                         -> IfElse             {cons("Block")}
    "else" Statement                         -> IfElse             {cons("Single")}
    "if" "(" Expression ")"                  -> IfHeader           {cons("Declaration")}
    Type ID ";"                              -> Variable           {cons("Declaration")}
    Type ID "[];"                            -> Variable           {cons("DeclarationArray")}
    Type ID "=" Expression ";"               -> Variable           {cons("DeclarationInst")}
    Type ID                                  -> Parameter          {cons("Parameter")}
    Parameter "," Parameter                  -> Parameter          {cons("Separator"), left}
    Expression                               -> Argument           {cons("Parameter")}
    Expression "," Expression                -> Argument           {cons("Separator"), left}
    Expression OperatorTerm Expression       -> Expression         {cons("Add"), left}
    Expression OperatorFactor Expression     -> Expression         {cons("Mul"), left}
    Expression OperatorComparator Expression -> Expression         {cons("Logic"), left}
    Primitive                                -> Expression         {cons("Primitive")}
    "(" Expression ")"                       -> Expression         {cons("Expression")}
    INT                                      -> Primitive          {cons("Num")}
    CHAR                                     -> Primitive          {cons("Char")}
    BOOLEAN                                  -> Primitive          {cons("Boolean")}
    ID                                       -> Primitive          {cons("Variable")}
    ID "(" Argument* ")"                     -> Primitive          {cons("Function")}
    "+"                                      -> OperatorTerm       {cons("Add")}
    "-"                                      -> OperatorTerm       {cons("Sub")}
    "*"                                      -> OperatorFactor     {cons("Mul")}
    "/"                                      -> OperatorFactor     {cons("Div")}
    "=="                                     -> OperatorComparator {cons("Equal")}
    "!="                                     -> OperatorComparator {cons("Diff")}
    ">"                                      -> OperatorComparator {cons("GT")}
    ">="                                     -> OperatorComparator {cons("GTE")}
    "<"                                      -> OperatorComparator {cons("LT")}
    "<="                                     -> OperatorComparator {cons("LTE")}
    "&&"                                     -> OperatorComparator {cons("And")}
    "||"                                     -> OperatorComparator {cons("Or")}
    "void"                                   -> Type               {cons("Void")}
    "int"                                    -> Type               {cons("Integer")}
    "char"                                   -> Type               {cons("Char")}
    "bool"                                   -> Type               {cons("Boolean")}
    "print" "(" Primitive ")"                -> BasicFunction      {cons("printPrimitive")}
    "scan" "(" INPUT* "," ID* ")"            -> BasicFunction      {cons("scan")}

  lexical syntax
    

  context-free syntax
    "$Start"              -> Start              {cons("Start-Plhdr"), placeholder}
    "$Program"            -> Program            {cons("Program-Plhdr"), placeholder}
    "$GlobalVariable"     -> GlobalVariable     {cons("GlobalVariable-Plhdr"), placeholder}
    "$Structure"          -> Structure          {cons("Structure-Plhdr"), placeholder}
    "$Function"           -> Function           {cons("Function-Plhdr"), placeholder}
    "$If"                 -> If                 {cons("If-Plhdr"), placeholder}
    "$CodeBlock"          -> CodeBlock          {cons("CodeBlock-Plhdr"), placeholder}
    "$IfElse"             -> IfElse             {cons("IfElse-Plhdr"), placeholder}
    "$Statement"          -> Statement          {cons("Statement-Plhdr"), placeholder}
    "$IfHeader"           -> IfHeader           {cons("IfHeader-Plhdr"), placeholder}
    "$Variable"           -> Variable           {cons("Variable-Plhdr"), placeholder}
    "$Parameter"          -> Parameter          {cons("Parameter-Plhdr"), placeholder}
    "$Expression"         -> Expression         {cons("Expression-Plhdr"), placeholder}
    "$INT"                -> INT                {cons("INT-Plhdr"), placeholder}
    "$CHAR"               -> CHAR               {cons("CHAR-Plhdr"), placeholder}
    "$BOOLEAN"            -> BOOLEAN            {cons("BOOLEAN-Plhdr"), placeholder}
    "$Argument"           -> Argument           {cons("Argument-Plhdr"), placeholder}
    "$OperatorTerm"       -> OperatorTerm       {cons("OperatorTerm-Plhdr"), placeholder}
    "$OperatorFactor"     -> OperatorFactor     {cons("OperatorFactor-Plhdr"), placeholder}
    "$OperatorComparator" -> OperatorComparator {cons("OperatorComparator-Plhdr"), placeholder}
    "$Type"               -> Type               {cons("Type-Plhdr"), placeholder}
    "$Primitive"          -> Primitive          {cons("Primitive-Plhdr"), placeholder}
    "$BasicFunction"      -> BasicFunction      {cons("BasicFunction-Plhdr"), placeholder}
    "$INPUT"              -> INPUT              {cons("INPUT-Plhdr"), placeholder}
    "$ID"                 -> ID                 {cons("ID-Plhdr"), placeholder}

  context-free priorities
    Expression OperatorFactor Expression -> Expression >
    {left:
      Expression OperatorTerm Expression -> Expression
    } >
    Expression OperatorComparator Expression -> Expression